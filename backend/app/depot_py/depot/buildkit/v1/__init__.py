# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: buildkit/v1/buildkit.proto
# plugin: python-betterproto
# This file has been @generated

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from dataclasses import dataclass
else:
    from pydantic.dataclasses import dataclass

from collections.abc import AsyncIterable, AsyncIterator, Iterable
from typing import (
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase
from pydantic import model_validator
from pydantic.dataclasses import rebuild_dataclass


class Platform(betterproto.Enum):
    UNSPECIFIED = 0
    AMD64 = 1
    ARM64 = 2

    @classmethod
    def __get_pydantic_core_schema__(cls, _source_type, _handler):
        from pydantic_core import core_schema

        return core_schema.int_schema(ge=0)


@dataclass(eq=False, repr=False)
class GetEndpointRequest(betterproto.Message):
    build_id: str = betterproto.string_field(1)
    platform: "Platform" = betterproto.enum_field(2)


@dataclass(eq=False, repr=False)
class GetEndpointResponse(betterproto.Message):
    pending: Optional[
        "GetEndpointResponsePendingConnection"
    ] = betterproto.message_field(1, optional=True, group="connection")
    active: Optional["GetEndpointResponseActiveConnection"] = betterproto.message_field(
        2, optional=True, group="connection"
    )

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


@dataclass(eq=False, repr=False)
class GetEndpointResponsePendingConnection(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetEndpointResponseActiveConnection(betterproto.Message):
    endpoint: str = betterproto.string_field(1)
    server_name: str = betterproto.string_field(2)
    cert: "CertificatePair" = betterproto.message_field(3)
    ca_cert: "PublicCertificate" = betterproto.message_field(4)


@dataclass(eq=False, repr=False)
class ReleaseEndpointRequest(betterproto.Message):
    build_id: str = betterproto.string_field(1)
    platform: "Platform" = betterproto.enum_field(2)


@dataclass(eq=False, repr=False)
class ReleaseEndpointResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class PublicCertificate(betterproto.Message):
    cert: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class PrivateKey(betterproto.Message):
    key: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class CertificatePair(betterproto.Message):
    cert: "PublicCertificate" = betterproto.message_field(1)
    key: "PrivateKey" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class ReportHealthRequest(betterproto.Message):
    build_id: str = betterproto.string_field(1)
    platform: "Platform" = betterproto.enum_field(2)


@dataclass(eq=False, repr=False)
class ReportHealthResponse(betterproto.Message):
    pass


class BuildKitServiceStub(betterproto.ServiceStub):
    async def get_endpoint(
        self,
        get_endpoint_request: "GetEndpointRequest",
        *,
        timeout: float | None = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> AsyncIterator[GetEndpointResponse]:
        async for response in self._unary_stream(
            "/depot.buildkit.v1.BuildKitService/GetEndpoint",
            get_endpoint_request,
            GetEndpointResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def report_health(
        self,
        report_health_request_iterator: AsyncIterable[ReportHealthRequest]
        | Iterable[ReportHealthRequest],
        *,
        timeout: float | None = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "ReportHealthResponse":
        return await self._stream_unary(
            "/depot.buildkit.v1.BuildKitService/ReportHealth",
            report_health_request_iterator,
            ReportHealthRequest,
            ReportHealthResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def release_endpoint(
        self,
        release_endpoint_request: "ReleaseEndpointRequest",
        *,
        timeout: float | None = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "ReleaseEndpointResponse":
        return await self._unary_unary(
            "/depot.buildkit.v1.BuildKitService/ReleaseEndpoint",
            release_endpoint_request,
            ReleaseEndpointResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class BuildKitServiceBase(ServiceBase):
    async def get_endpoint(
        self, get_endpoint_request: "GetEndpointRequest"
    ) -> AsyncIterator[GetEndpointResponse]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield GetEndpointResponse()

    async def report_health(
        self, report_health_request_iterator: AsyncIterator[ReportHealthRequest]
    ) -> "ReportHealthResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def release_endpoint(
        self, release_endpoint_request: "ReleaseEndpointRequest"
    ) -> "ReleaseEndpointResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_endpoint(
        self, stream: "grpclib.server.Stream[GetEndpointRequest, GetEndpointResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_endpoint,
            stream,
            request,
        )

    async def __rpc_report_health(
        self, stream: "grpclib.server.Stream[ReportHealthRequest, ReportHealthResponse]"
    ) -> None:
        request = stream.__aiter__()
        response = await self.report_health(request)
        await stream.send_message(response)

    async def __rpc_release_endpoint(
        self,
        stream: "grpclib.server.Stream[ReleaseEndpointRequest, ReleaseEndpointResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.release_endpoint(request)
        await stream.send_message(response)

    def __mapping__(self) -> dict[str, grpclib.const.Handler]:
        return {
            "/depot.buildkit.v1.BuildKitService/GetEndpoint": grpclib.const.Handler(
                self.__rpc_get_endpoint,
                grpclib.const.Cardinality.UNARY_STREAM,
                GetEndpointRequest,
                GetEndpointResponse,
            ),
            "/depot.buildkit.v1.BuildKitService/ReportHealth": grpclib.const.Handler(
                self.__rpc_report_health,
                grpclib.const.Cardinality.STREAM_UNARY,
                ReportHealthRequest,
                ReportHealthResponse,
            ),
            "/depot.buildkit.v1.BuildKitService/ReleaseEndpoint": grpclib.const.Handler(
                self.__rpc_release_endpoint,
                grpclib.const.Cardinality.UNARY_UNARY,
                ReleaseEndpointRequest,
                ReleaseEndpointResponse,
            ),
        }


rebuild_dataclass(GetEndpointRequest)  # type: ignore
rebuild_dataclass(GetEndpointResponse)  # type: ignore
rebuild_dataclass(GetEndpointResponseActiveConnection)  # type: ignore
rebuild_dataclass(ReleaseEndpointRequest)  # type: ignore
rebuild_dataclass(CertificatePair)  # type: ignore
rebuild_dataclass(ReportHealthRequest)  # type: ignore
